import groovy.sql.Sql

apply plugin: 'war'
	
assert System.env.JBOSS_HOME!=null	



repositories {
	mavenCentral()
}

configurations {
	jdbcdriver
}



dependencies {
	providedCompile files("$System.env.JBOSS_HOME/modules/system/layers/base/javax/inject/api/main/javax.inject-1.jar",
				          "$System.env.JBOSS_HOME/modules/system/layers/base/javax/enterprise/api/main/cdi-api-1.1.jar",
						  "$System.env.JBOSS_HOME/modules/system/layers/base/javax/validation/api/main/validation-api-1.1.0.Final.jar",
						  "$System.env.JBOSS_HOME/modules/system/layers/base/javax/ejb/api/main/jboss-ejb-api_3.2_spec-1.0.0.Final.jar",
						  "$System.env.JBOSS_HOME/modules/system/layers/base/javax/persistence/api/main/hibernate-jpa-2.1-api-1.0.0.Final.jar")

	jdbcdriver 'com.h2database:h2:1.3.173','org.postgresql:postgresql:9.3-1100-jdbc41'
	
}


//we need the hack to satisfy the classloader conditions for javax.sql.DriverManager
URLClassLoader loader = GroovyObject.class.classLoader
configurations.jdbcdriver.each {File file ->
	loader.addURL(file.toURI().toURL())
}
println "jdbc drivers: "+Class.forName("org.h2.Driver")+", "+Class.forName("org.postgresql.Driver")


task buildId << {	
	buildDir.mkdirs()
	// generate timestamp and user for build_id
	def build_id=new Date().format('yyyyMMdd HHmm ')+System.properties.'user.name'
	
	try {
		// get git status und ref
		def gitref="git rev-parse --short HEAD".execute().text.trim()
		def gittag="git describe --tags --always $gitref".execute().text.trim()
		//if(gitref!=gittag) { gitref="$gittag $gitref"}
		def gitdirty="git status --porcelain".execute().text.isEmpty()?" ":"*"
		build_id+=" $gittag$gitdirty"
	}
	catch (Exception x) {
		println "Warning: no git executable, using simple buildId"
	}
	println "buildId: $build_id"
	
	// and write build_id to file
	new File("$buildDir/build_id.txt").withWriter { out -> out.println build_id }
}


war.dependsOn buildId
war {
	metaInf { 
		from "$buildDir/build_id.txt" 
		from "$projectDir/src/main//resources/META-INF/persistence.xml"
	}
}

task deploy(dependsOn: war) {
		def warfile="$buildDir/libs/${project.name}.war"
		def cmd="$System.env.JBOSS_HOME"+"/bin/jboss-cli.sh"

		def process="$cmd --connect --command=\"deploy --force $warfile\"".execute()
		process.waitFor()
		if(process.exitValue()!=0) {
			thow new RuntimeException("deploy failed of $warfile");
		}
				
}
	
task show << {
	buildscript.configurations.classpath.each { println it }
 }


task loadDB(dependsOn: deploy) << {
	new File("${System.properties.'user.home'}/system.properties").withInputStream {
		System.properties.load(it)
	}
	println "connecting to database: ${System.properties.'exampleds.jdbc.url'}\nas user: ${System.properties.'exampleds.user'}"
	def sql= Sql.newInstance("${System.properties.'exampleds.jdbc.url'}",
					    "${System.properties.'exampleds.user'}",
						"${System.properties.'exampleds.password'}")
	sql.execute("insert into users (name,email) values ('mick', 'mick@test.com')")
	sql.execute("insert into users (name,email) values ('alice', 'alice@test.com')")
	sql.execute("insert into users (name,email) values ('donald', 'don@test.com')")
	sql.close()
}

